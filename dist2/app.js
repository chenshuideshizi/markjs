/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => {
  // webpackBootstrap
  /******/ "use strict";
  /******/ var __webpack_modules__ = {
    /***/ "./node_modules/deepmerge/dist/cjs.js":
      /*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
      /***/ (module) => {
        eval(
          "\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n\n\n//# sourceURL=webpack://markjs/./node_modules/deepmerge/dist/cjs.js?"
        );

        /***/
      },

    /***/ "./src/index.js":
      /*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _mark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mark */ "./src/mark.js");\n\n\n_mark__WEBPACK_IMPORTED_MODULE_0__["default"].install  = (Vue) => {\n    Vue.components(_mark__WEBPACK_IMPORTED_MODULE_0__["default"].name, _mark__WEBPACK_IMPORTED_MODULE_0__["default"])\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_mark__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n//# sourceURL=webpack://markjs/./src/index.js?'
        );

        /***/
      },

    /***/ "./src/mark.js":
      /*!*********************!*\
  !*** ./src/mark.js ***!
  \*********************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          "__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _src_observer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/observer */ \"./src/src/observer.js\");\n/* harmony import */ var _src_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/utils */ \"./src/src/utils.js\");\n/* harmony import */ var _src_plugins_edit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/plugins/edit */ \"./src/src/plugins/edit.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! deepmerge */ \"./node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n/*\n配置\n{\n    el: Object, // 容器元素，dom元素或选择器字符串\n    dbClickTime: 200,// 双击间隔事件，默认200ms\n    mobile: false// 是否是移动端模式，默认false\n}\n\n事件\non(event, callback)，事件监听，CLICK、DOUBLE-CLICK、MOUSEDOWN、MOUSEMOVE、MOUSEUP、MOUSEENTER、MOUSELEAVE、WINDOW-CLICK\n*/\n\n// 默认配置\nconst defaultOpt = {\n    dbClickTime: 200,\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2020-09-27 14:02:06 \n * @Desc: 标注库 \n */\nclass Markjs {\n    static pluginList = []\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 10:27:23 \n     * @Desc: 安装插件 \n     */\n    static use(plugin, index = -1) {\n        if (!plugin) {\n            return\n        }\n        if (plugin.used) {\n            return this\n        }\n        plugin.used = true\n        if (index === -1) {\n            Markjs.pluginList.push(plugin)\n        } else {\n            Markjs.pluginList.splice(index, 0, plugin)\n        }\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 14:02:12 \n     * @Desc: 构造函数 \n     */\n    constructor(opt = {}) {\n        if (!opt.el) {\n            throw new Error('el属性为空')\n        }\n        // 配置项\n        this.opt = {\n            ...defaultOpt,\n            ...opt\n        }\n        // 容器元素\n        this.el = typeof opt.el === 'string' ? document.querySelector(opt.el) : opt.el\n        if (!this.el) {\n            throw new Error('容器元素获取失败')\n        }\n        // 容器元素的尺寸信息\n        this.elRectInfo = null\n        // canvas元素\n        this.canvasEle = null\n        // 绘图元素尺寸信息\n        this.canvasEleRectInfo = null\n        // 绘图上下文\n        this.ctx = null\n        // 单击定时器\n        this.clickTimer = null\n        // 发布订阅对象\n        this.observer = new _src_observer__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\n        // 鼠标按下的位置\n        this.mousedownPos = {\n            x: 0,\n            y: 0\n        }\n        // 鼠标松开的位置\n        this.mouseupPos = {\n            x: 0,\n            y: 0\n        }\n        // 鼠标上次点击的时间\n        this.lastClickTime = 0\n\n        // 固化事件函数的this\n        this.bindEventCallback()\n        // 初始化\n        this.init()\n        // 注册插件\n        this.usePlugins()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-10-25 13:52:52 \n     * @Desc: 更新配置 \n     */\n    updateOpt(newOpt) {\n        this.opt = deepmerge__WEBPACK_IMPORTED_MODULE_3___default()(this.opt, newOpt)\n        this.emit('UPDATED_OPT', this.opt)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 10:35:33 \n     * @Desc: 注册插件 \n     */\n    usePlugins() {\n        let index = 0\n        let len = Markjs.pluginList.length\n        let loopUse = () => {\n            if (index >= len) {\n                this.emit('PLUGINS_LOADED')\n                return\n            }\n            let cur = Markjs.pluginList[index]\n            cur(this, _src_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"]).then(() => {\n                index++\n                loopUse()\n            })\n        }\n        loopUse()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-10-25 14:03:12 \n     * @Desc: 触发事件 \n     */\n    emit(event, ...args) {\n        this.observer.publish(event, ...args)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 13:54:58 \n     * @Desc: 监听事件 \n     */\n    on(event, callback) {\n        return this.observer.subscribe(event, callback)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 13:56:06 \n     * @Desc: 解除监听事件 \n     */\n    off(token) {\n        this.observer.unsubscribe(token)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 14:06:54 \n     * @Desc: 初始化 \n     */\n    init() {\n        this.createElement()\n        this.ctx = this.canvasEle.getContext('2d')\n        this.bindEvent()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:11:03 \n     * @Desc: 销毁 \n     */\n    destroy() {\n        this.unbindEvent()\n        this.el.removeChild(this.canvasEle)\n        this.emit('DESTORY')\n        this.observer.clearAll()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 14:26:19 \n     * @Desc: 创建元素 \n     */\n    createElement() {\n        this.elRectInfo = this.el.getBoundingClientRect()\n        let {\n            width,\n            height\n        } = this.elRectInfo\n        this.canvasEle = document.createElement('canvas')\n        this.canvasEle.width = width\n        this.canvasEle.height = height\n        this.canvasEleRectInfo = {\n            width,\n            height\n        }\n        this.el.appendChild(this.canvasEle)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 16:55:53 \n     * @Desc:  固化事件函数的this\n     */\n    bindEventCallback() {\n        this.onclick = this.onclick.bind(this)\n        this.onmousedown = this.onmousedown.bind(this)\n        this.onmousemove = this.onmousemove.bind(this)\n        this.onmouseup = this.onmouseup.bind(this)\n        this.onmouseenter = this.onmouseenter.bind(this)\n        this.onmouseleave = this.onmouseleave.bind(this)\n        this.onWindowClick = this.onWindowClick.bind(this)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 14:55:12 \n     * @Desc: 绑定事件 \n     */\n    bindEvent() {\n        let isMobile = this.opt.mobile\n        this.canvasEle.addEventListener('click', this.onclick)\n        this.canvasEle.addEventListener(isMobile ? 'touchstart' : 'mousedown', this.onmousedown)\n        this.canvasEle.addEventListener(isMobile ? 'touchmove' : 'mousemove', this.onmousemove)\n        window.addEventListener(isMobile ? 'touchend' : 'mouseup', this.onmouseup)\n        this.canvasEle.addEventListener('mouseenter', this.onmouseenter)\n        this.canvasEle.addEventListener('mouseleave', this.onmouseleave)\n        window.addEventListener('click', this.onWindowClick)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 14:57:23 \n     * @Desc: 解绑事件 \n     */\n    unbindEvent() {\n        let isMobile = this.opt.mobile\n        this.canvasEle.removeEventListener('click', this.onclick)\n        this.canvasEle.removeEventListener(isMobile ? 'touchstart' : 'mousedown', this.onmousedown)\n        this.canvasEle.removeEventListener(isMobile ? 'touchmove' : 'mousemove', this.onmousemove)\n        window.removeEventListener(isMobile ? 'touchend' : 'mouseup', this.onmouseup)\n        this.canvasEle.removeEventListener('mouseenter', this.onmouseenter)\n        this.canvasEle.removeEventListener('mouseleave', this.onmouseleave)\n        window.removeEventListener('click', this.onWindowClick)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 15:04:50 \n     * @Desc: 单击事件 \n     */\n    onclick(e) {\n        if (this.clickTimer) {\n            clearTimeout(this.clickTimer)\n            this.clickTimer = null\n        }\n\n        this.clickTimer = setTimeout(() => {\n            this.emit('CLICK', e)\n        }, this.opt.dbClickTime);\n\n        if (Date.now() - this.lastClickTime <= this.opt.dbClickTime) {\n            clearTimeout(this.clickTimer)\n            this.clickTimer = null\n            this.lastClickTime = 0\n            this.emit('DOUBLE-CLICK', e)\n        }\n\n        this.lastClickTime = Date.now()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:02:26 \n     * @Desc: 鼠标按下事件 \n     */\n    onmousedown(e) {\n        if (this.opt.mobile) {\n            e = e.touches[0]\n        }\n        this.mousedownPos = {\n            x: e.clientX,\n            y: e.clientY\n        }\n        this.emit('MOUSEDOWN', e)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:02:26 \n     * @Desc: 鼠标移动事件 \n     */\n    onmousemove(e) {\n        if (this.opt.mobile) {\n            e = e.touches[0]\n        }\n        this.emit('MOUSEMOVE', e)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:02:26 \n     * @Desc: 鼠标松开事件 \n     */\n    onmouseup(e) {\n        if (this.opt.mobile) {\n            e = e.touches[0]\n        }\n        if (!e) {\n            e = {\n                clientX: 0,\n                clientY: 0\n            }\n        }\n        this.mouseupPos = {\n            x: e.clientX,\n            y: e.clientY\n        }\n        this.emit('MOUSEUP', e)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:05:29 \n     * @Desc: 鼠标移入事件 \n     */\n    onmouseenter(e) {\n        this.emit('MOUSEENTER', e)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:06:28 \n     * @Desc: 鼠标移出事件 \n     */\n    onmouseleave(e) {\n        this.emit('MOUSELEAVE', e)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:07:31 \n     * @Desc: window的点击事件 \n     */\n    onWindowClick(e) {\n        this.emit('WINDOW-CLICK', e)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 15:56:54 \n     * @Desc: 清除画布 \n     */\n    clearCanvas() {\n        this.ctx.clearRect(0, 0, this.canvasEle.width, this.canvasEle.height)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 16:57:03 \n     * @Desc: 鼠标坐标转为相对canvas的坐标 \n     */\n    toCanvasPos(e) {\n        let cx = e.clientX\n        let cy = e.clientY\n        let {\n            left,\n            top\n        } = this.canvasEle.getBoundingClientRect()\n        let x = cx - left\n        let y = cy - top\n        return {\n            x,\n            y\n        }\n    }\n}\n\nMarkjs.use(_src_plugins_edit__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Markjs);\n\n//# sourceURL=webpack://markjs/./src/mark.js?"
        );

        /***/
      },

    /***/ "./src/src/markItem.js":
      /*!*****************************!*\
  !*** ./src/src/markItem.js ***!
  \*****************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          "__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MarkItem)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/src/utils.js\");\n\n\n/*\n// 配置\n{\n    data: null,// 附加数据，可以添加你需要的任何数据\n    lineType: 'line',线段类型，line（普通线段）、borderLine（带边框的线段）、custom（自定义绘图方法）\n    customRenderLine(this){},// 自定义绘制线段的方法\n    strokeStyle: {// 标注轮廓样式\n        lineWidth: 3,\n        strokeColor: 'rgba(0, 136, 255, 1)',\n        lineJoin: 'round',\n        // 如果lineType为borderLine，需要配置一下三个属性\n        frontLineWidth: 3,\n        frontStrokeColor: 'rgba(0, 136, 255, 1)',\n        frontLineJoin: 'round'\n    },\n    fillColor: 'rgba(0, 136, 255, 0.5)',// 标注区域填充颜色\n    pointStyle: {// 端点的样式\n        lineWidth: 3,\n        strokeColor: 'rgba(0, 136, 255, 1)',\n        fillColor: 'rgba(0, 136, 255, 0.5)'\n    },\n    pointArr: [// 回显的标注区域数据\n        {\n            data: null,//附加数据\n            pointArr: [{// 点位数据\n                {\"x\":0,\"y\":0}\n            }],\n            strokeStyle: {},\n            fillColor: '',\n            pointStyle:{}\n        }\n    ]\n}\n\n\n*/\n\n// 默认的线条样式\nconst defaultStrokeStyle = {\n    lineWidth: 3,\n    strokeColor: 'rgba(0, 136, 255, 1)',\n    lineJoin: 'round',\n    frontLineWidth: 3,\n    frontStrokeColor: 'rgba(0, 136, 255, 1)',\n    frontLineJoin: 'round'\n}\n// 默认填充样式\nconst defaultFillColor = 'rgba(0, 136, 255, 0.5)'\n// 默认的端点样式\nconst defaultPointStyle = {\n    lineWidth: 3,\n    strokeColor: 'rgba(0, 136, 255, 1)',\n    fillColor: 'rgba(0, 136, 255, 0.5)'\n}\n// 默认配置\nconst defaultOpt = {\n    showPoint: true,\n    pointType: 'square',\n    pointWidth: 3,\n    lineType: 'line'\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2020-09-27 15:12:17 \n * @Desc: 单个标注对象 \n */\nclass MarkItem {\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 15:12:11 \n     * @Desc: 构造函数 \n     */\n    constructor(ctx = null, opt = {}) {\n        // canvas上下文\n        this.ctx = ctx\n        this.updateOpt(opt)\n        // 自定义更新端点位置的方法\n        this.updatePointFn = opt.updatePoint\n        // 点位数组{x,y}\n        this.pointArr = opt.pointArr || []\n        // 路径是否已经闭合了\n        this.isClosePath = false\n        // 是否是编辑状态\n        this.isEditing = false\n        // 是否是拖动状态\n        this.isDragging = false\n        // 拖动的端点索引，没有则代表拖拽整体\n        this.dragPointIndex = -1\n        // 点位数组缓存，用于整体拖动\n        this.dragCachePointArr = []\n        // 鼠标滑过显示可选择状态\n        this.hoverActive = false\n        // 始终闭合绘制模式下的当前鼠标移动到的非固定点\n        this.areaToPointPos = null\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-10-25 14:19:00 \n     * @Desc: 更新配置数据 \n     */\n    updateOpt(opt) {\n        // 配置\n        this.opt = {\n            ...defaultOpt,\n            ...opt\n        }\n        // 附加数据\n        this.data = opt.data || null\n        // 线段绘制样式\n        this.strokeStyle = opt.strokeStyle ? {\n            ...defaultStrokeStyle,\n            ...opt.strokeStyle\n        } : defaultStrokeStyle\n        // 填充样式\n        this.fillColor = opt.fillColor || defaultFillColor\n        // 端点样式\n        this.pointStyle = opt.pointStyle ? {\n            ...defaultPointStyle,\n            ...opt.pointStyle\n        } : defaultPointStyle\n        // 是否是闭合绘制模式\n        this.area = opt.area || false\n        // 是否允许新增节点，仅在闭合情况下的编辑期间\n        this.enableAddPoint = opt.enableAddPoint || false\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 15:17:35 \n     * @Desc: 开启编辑 \n     */\n    enable() {\n        this.isEditing = true\n        // 插入虚拟顶点\n        this.insertFictitiousPoints()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 15:17:53 \n     * @Desc: 结束编辑 \n     */\n    disable() {\n        this.isEditing = false\n        // 移除虚拟顶点\n        this.removeFictitiousPoints()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-01-25 14:45:32 \n     * @Desc: 获取真实顶点数组 \n     */\n    getTruePointArr() {\n        return this.pointArr.filter((item) => {\n            return !item.fictitious\n        })\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:24:50 \n     * @Desc: 端点数量 \n     */\n    getPointLength() {\n        return this.getTruePointArr().length\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 15:54:50 \n     * @Desc: 添加端点 \n     */\n    pushPoint(x, y) {\n        if (!this.isEditing || this.isClosePath) {\n            return\n        }\n        this.pointArr.push({\n            x,\n            y\n        })\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-11-05 10:41:36 \n     * @Desc: 删除某个顶点 \n     */\n    removePoint(index) {\n        // 点击的是虚拟节点直接返回\n        if (this.pointArr[index].fictitious) {\n            return\n        }\n        this.pointArr.splice(index, 1)\n        // 删除后需要重新创建虚拟节点\n        this.removeFictitiousPoints()\n        this.insertFictitiousPoints()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-01-22 09:32:47 \n     * @Desc: 始终闭合模式下的当前鼠标移动到的非固定点 \n     */\n    areaToPoint(x, y) {\n        this.areaToPointPos = {\n            x,\n            y\n        }\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 15:57:47 \n     * @Desc: 渲染 \n     */\n    render() {\n        // 填充区域\n        if (this.isClosePath || this.area) {\n            this.renderArea()\n        }\n        // 绘制线段\n        if (this.opt.lineType === 'custom') {\n            this.opt.customRenderLine && this.opt.customRenderLine(this)\n        } else if (this.opt.lineType === 'borderLine') {\n            this.renderLines(this.strokeStyle)\n            this.renderLines({\n                ...this.strokeStyle,\n                lineWidth: this.strokeStyle.frontLineWidth,\n                strokeColor: this.strokeStyle.frontStrokeColor,\n                lineJoin: this.strokeStyle.frontLineJoin\n            })\n        } else {\n            this.renderLines(this.strokeStyle)\n        }\n        // 绘制端点\n        this.renderPoints()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 17:04:16 \n     * @Desc:  填充区域\n     */\n    renderArea() {\n        this.ctx.save()\n        this.ctx.fillStyle = this.fillColor\n        this.ctx.beginPath()\n        let _pointArr = this.pointArr.concat(this.area ? this.areaToPointPos ? [this.areaToPointPos] : [] : [])\n        for (let i = 0; i < _pointArr.length; i++) {\n            let x = _pointArr[i].x\n            let y = _pointArr[i].y\n            if (i === 0) {\n                this.ctx.moveTo(x, y)\n            } else {\n                this.ctx.lineTo(x, y)\n            }\n        }\n        this.ctx.closePath()\n        this.ctx.fill()\n        this.ctx.restore()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 15:16:37 \n     * @Desc: 绘制线段 \n     */\n    renderLines({\n        lineWidth,\n        strokeColor,\n        lineJoin\n    }, onlyPath) {\n        this.ctx.save()\n        this.ctx.lineWidth = lineWidth\n        this.ctx.strokeStyle = strokeColor\n        this.ctx.lineJoin = lineJoin\n        this.ctx.beginPath()\n        let _pointArr = this.pointArr.concat(this.area ? this.areaToPointPos ? [this.areaToPointPos] : [] : [])\n        for (let i = 0; i < _pointArr.length; i++) {\n            let x = _pointArr[i].x\n            let y = _pointArr[i].y\n            if (i === 0) {\n                this.ctx.moveTo(x, y)\n            } else {\n                this.ctx.lineTo(x, y)\n            }\n        }\n        // 闭合路径\n        if (this.isClosePath || this.area) {\n            this.ctx.closePath()\n        }\n        // 不实际绘制出来\n        if (!onlyPath) {\n            this.ctx.stroke()\n        }\n        this.ctx.restore()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 17:54:18 \n     * @Desc:  绘制端点\n     */\n    renderPoints(onlyPath, callback) {\n        for (let i = 0; i < this.pointArr.length; i++) {\n            this.ctx.beginPath()\n            let x = this.pointArr[i].x\n            let y = this.pointArr[i].y\n            if (this.isEditing || onlyPath || this.hoverActive) {\n                this.drawPoint(x, y, onlyPath, false, this.pointArr[i].fictitious)\n                callback && callback(i)\n            }\n        }\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-01-25 10:48:01 \n     * @Desc: 插入虚拟节点 \n     */\n    insertFictitiousPoints() {\n        if (!this.isEditing || !this.isClosePath || !this.enableAddPoint) {\n            return\n        }\n        // 先去掉虚拟节点\n        this.removeFictitiousPoints()\n\n        let points = []\n        let arr = this.pointArr\n        let len = arr.length\n        for (let i = 0; i < len - 1; i++) {\n            let s = arr[i]\n            let e = arr[i + 1]\n            points.push({\n                x: (s.x + e.x) / 2,\n                y: (s.y + e.y) / 2,\n                fictitious: true\n            })\n        }\n        points.push({\n            x: (arr[len - 1].x + arr[0].x) / 2,\n            y: (arr[len - 1].y + arr[0].y) / 2,\n            fictitious: true\n        })\n        \n        // 插入\n        let newArr = []\n        for (let i = 0; i < this.pointArr.length; i++) {\n            newArr.push(this.pointArr[i])\n            newArr.push(points.shift())\n        }\n\n        this.pointArr = newArr\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-01-25 14:07:12 \n     * @Desc:  去掉虚拟节点\n     */\n    removeFictitiousPoints() {\n        this.pointArr = this.getTruePointArr()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 17:57:19 \n     * @Desc: 绘制点 \n     */\n    drawPoint(x, y, onlyPath, beginPath, reverse) {\n        let {\n            customRenderPoint,\n            showPoint,\n            pointType,\n            pointWidth\n        } = this.opt\n        if (beginPath) {\n            this.ctx.beginPath()\n        }\n        // 用户自定义绘制端点方法\n        if (customRenderPoint) {\n            customRenderPoint(this.ctx, x, y, onlyPath, this.pointStyle)\n        } else { // 预定义绘制端点方法\n            this.ctx.save()\n            this.ctx.lineWidth = this.pointStyle.lineWidth\n            this.ctx.strokeStyle = this.pointStyle.strokeColor\n            this.ctx.fillStyle = this.pointStyle.fillColor\n            // 反向样式，边框和填充的颜色互换，用于虚拟节点的显示\n            if (reverse) {\n                this.ctx.strokeStyle = this.pointStyle.fillColor\n                this.ctx.fillStyle = this.pointStyle.strokeColor\n            }\n            switch (pointType) {\n                case 'square':\n                    this.ctx.rect(x - pointWidth, y - pointWidth, pointWidth * 2, pointWidth * 2)\n                    break;\n                case 'circle':\n                    this.ctx.arc(x, y, pointWidth * 2, 0, 2 * Math.PI)\n                    break;\n                default:\n                    break;\n            }\n            // 不实际绘制出来\n            if (!onlyPath) {\n                if (showPoint) {\n                    this.ctx.fill()\n                    this.ctx.stroke()\n                }\n            }\n            this.ctx.restore()\n        }\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 15:14:29 \n     * @Desc: 检测某个点是否在该路径内 \n     */\n    checkInPath(x, y) {\n        this.renderLines(this.strokeStyle, true)\n        return this.ctx.isPointInPath(x, y)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 15:48:51 \n     * @Desc: 判断某个点是否在某个端点内 \n     */\n    checkInPoints(x, y) {\n        let index = -1\n        this.renderPoints(true, (i) => {\n            if (this.ctx.isPointInPath(x, y)) {\n                index = i\n            }\n        })\n        return index\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:23:34 \n     * @Desc: 闭合路径 \n     */\n    closePath() {\n        this.areaToPointPos = null\n        this.isClosePath = true\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 16:54:34 \n     * @Desc: 允许拖动\n     */\n    enableDrag(pointIndex = -1) {\n        this.isDragging = true\n        this.dragPointIndex = pointIndex\n        this.dragCachePointArr = JSON.parse(JSON.stringify(this.pointArr))\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-01-25 14:25:32 \n     * @Desc: 获取某个顶点在没有虚拟顶点的情况下的真实索引 \n     */\n    getTruePointIndex(index) {\n        if (index === -1 || this.pointArr[index].fictitious) {\n            return index\n        }\n        let count = 0\n        for (let i = 0; i < index; i++) {\n            if (this.pointArr[i].fictitious) {\n                count++\n            }\n        }\n        return index - count\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 18:33:02 \n     * @Desc: 停止拖动 \n     */\n    disableDrag() {\n        this.isDragging = false\n        this.dragPointIndex = -1\n        this.dragCachePointArr = []\n        // 拖动结束后恢复虚拟节点的创建\n        this.insertFictitiousPoints()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 17:04:23 \n     * @Desc: 拖动某个端点\n     */\n    dragPoint(x, y, ...args) {\n        if (!this.isDragging || this.dragPointIndex === -1) {\n            return\n        }\n        // 拖动的是虚拟点，则转换成真实点\n        if (this.pointArr[this.dragPointIndex].fictitious) {\n            delete this.pointArr[this.dragPointIndex].fictitious\n        }\n        // 获取某个顶点的真实索引\n        this.dragPointIndex = this.getTruePointIndex(this.dragPointIndex)\n        // 拖动时隐藏虚拟节点\n        this.removeFictitiousPoints()\n        if (this.updatePointFn) {\n            this.updatePointFn(this, x, y, ...args)\n        } else {\n            this.pointArr.splice(this.dragPointIndex, 1, {\n                ...this.pointArr[this.dragPointIndex],\n                x,\n                y\n            })\n        }\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 17:04:32 \n     * @Desc: 拖动整体 \n     */\n    dragAll(ox, oy) {\n        if (!this.isDragging) {\n            return\n        }\n        this.pointArr = this.dragCachePointArr.map((item) => {\n            return {\n                ...item,\n                x: item.x + ox,\n                y: item.y + oy\n            }\n        })\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 19:13:34 \n     * @Desc: 显示鼠标滑过时可选择状态\n     */\n    enableHoverActive() {\n        this.hoverActive = true\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 19:14:02 \n     * @Desc: 关闭鼠标滑过时可选择状态\n     */\n    disableHoverActive() {\n        this.hoverActive = false\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-21 20:23:44 \n     * @Desc: 遍历检查线段是否存在交叉情况 \n     */\n    checkLineSegmentCross() {\n        if (!this.checkCrossPrevCheck()) {\n            return false\n        }\n        // 已存在的线段\n        let lineSegments = this.createLineSegments(true)\n        let len = lineSegments.length\n        let cross = false\n        for (let i = 0; i < len; i++) {\n            let item = lineSegments[i]\n            if (this.checkCrossWithLineSegments(item[0], item[1], true)) {\n                cross = true\n            }\n        }\n        return cross\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-22 09:36:33 \n     * @Desc: 检查即将形成的线段是否会存在交叉 \n     */\n    checkNextLineSegmentCross(x, y) {\n        if (!this.checkCrossPrevCheck()) {\n            return false\n        }\n        let arr = this.getTruePointArr()\n        let len = arr.length\n        // 即将形成的线段\n        let c = {\n            x,\n            y\n        }\n        let d = arr[len - 1]\n        return this.checkCrossWithLineSegments(c, d)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-22 09:37:07 \n     * @Desc: 检查最后的闭合线段是否会存在交叉 \n     */\n    checkEndLineSegmentCross() {\n        if (!this.checkCrossPrevCheck()) {\n            return false\n        }\n        let arr = this.getTruePointArr()\n        let len = arr.length\n        let c = arr[len - 1]\n        let d = arr[0]\n        return this.checkCrossWithLineSegments(c, d)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-21 20:27:00 \n     * @Desc: 判断某条线段是否会与当前存在的线段交叉 \n     */\n    checkCrossWithLineSegments(c, d, close) {\n        // 已存在的线段\n        let lineSegments = this.createLineSegments(close)\n        let cross = false\n        for (let i = 0; i < lineSegments.length; i++) {\n            let item = lineSegments[i]\n            let a = item[0]\n            let b = item[1]\n            if (_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].checkLineSegmentCross(a, b, c, d)) {\n                cross = true\n            }\n        }\n        return cross\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-21 20:24:28 \n     * @Desc: 创建已存在点位组成的线段 \n     */\n    createLineSegments(close) {\n        let arr = this.getTruePointArr()\n        let len = arr.length\n        // 已存在的线段\n        let lineSegments = []\n        for (let i = 0; i < len - 1; i++) {\n            lineSegments.push([\n                arr[i],\n                arr[i + 1]\n            ])\n        }\n        // 包含起点和终点组成的线段\n        if (close) {\n            lineSegments.push([\n                arr[len - 1],\n                arr[0]\n            ])\n        }\n        return lineSegments\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-21 20:23:59 \n     * @Desc: 三个端点以下不可能交叉 \n     */\n    checkCrossPrevCheck() {\n        let len = this.getTruePointArr().length\n        // 三个端点以下不可能交叉\n        if (len <= 2) {\n            return false\n        }\n        return true\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-01-22 10:37:07 \n     * @Desc: 获取距离某个点最近的线段 \n     */\n    getPintNearestLine(x, y) {\n        let lineSegments = this.createLineSegments(this.isClosePath)\n        if (lineSegments.length <= 0) {\n            return null\n        }\n        if (this.dragPointIndex !== -1) {\n            if (this.dragPointIndex === 0) {\n                lineSegments.splice(0, 1)\n                lineSegments.splice(-1, 1)\n            } else {\n                lineSegments.splice(this.dragPointIndex - 1, 2)\n            }\n        }\n        let minNum = Infinity\n        let minLine\n        for (let i = 0; i < lineSegments.length; i++) {\n            let item = lineSegments[i]\n            let a = item[0]\n            let b = item[1]\n            let d = _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLinePointDistance(a.x, a.y, b.x, b.y, x, y)\n            if (d < minNum) {\n                minNum = d\n                minLine = item\n            }\n        }\n        return [minNum, minLine]\n    }\n}\n\n//# sourceURL=webpack://markjs/./src/src/markItem.js?"
        );

        /***/
      },

    /***/ "./src/src/observer.js":
      /*!*****************************!*\
  !*** ./src/src/observer.js ***!
  \*****************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          "__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Observer)\n/* harmony export */ });\nclass Observer {\n    /**\n     * javascript comment\n     * @Author: 王林25\n     * @Date: 2020-07-31 16:06:15\n     * @Desc: 构造函数\n     */\n    constructor () {\n        // 订阅的集合\n        this.observerListeners = {};\n        // 用于删除订阅\n        this.observerToken = 0;\n    }\n\n    /**\n     * javascript comment\n     * @Author: 王林25\n     * @Date: 2020-07-31 16:06:53\n     * @Desc: 发布话题\n     */\n    publish (topic, ...arg) {\n        if (!topic || !this.observerListeners[topic]) {\n            return false;\n        }\n        let subList = this.observerListeners[topic];\n        for (let i = 0; i < subList.length; i++) {\n            if (subList[i].context) {\n                subList[i].fn.apply(subList[i].context, arg);\n            } else {\n                subList[i].fn.apply(subList[i].fn, arg);\n            }\n        }\n    }\n\n    /**\n     * javascript comment\n     * @Author: 王林25\n     * @Date: 2020-07-31 16:07:19\n     * @Desc:  订阅某个话题\n     */\n    subscribe (topic, fn) {\n        let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n        if (!this.observerListeners[topic]) {\n            this.observerListeners[topic] = [];\n        }\n        this.observerToken++;\n        this.observerListeners[topic].push({\n            fn: fn,\n            context: context,\n            token: this.observerToken\n        });\n        return this.observerToken;\n    }\n\n    /**\n     * javascript comment\n     * @Author: 王林25\n     * @Date: 2020-07-31 16:07:46\n     * @Desc:  解除订阅\n     */\n    unsubscribe (token) {\n        if (!token) {\n            return false;\n        }\n        for (let k in this.observerListeners) {\n            if (this.observerListeners.hasOwnProperty(k)) {\n                for (let j = 0; j < this.observerListeners[k].length; j++) {\n                    if (this.observerListeners[k][j].token === token) {\n                        this.observerListeners[k].splice(j, 1);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * javascript comment\n     * @Author: 王林25\n     * @Date: 2020-07-31 16:08:16\n     * @Desc: 删掉某一类话题及其订阅\n     */\n    clearTopic (topic) {\n        if (!topic) {\n            return false;\n        }\n        for (let k in this.observerListeners) {\n            if (this.observerListeners.hasOwnProperty(k)) {\n                if (k === topic) {\n                    delete this.observerListeners[k];\n                }\n            }\n        }\n    }\n\n    /**\n     * javascript comment\n     * @Author: 王林25\n     * @Date: 2020-07-31 16:08:35\n     * @Desc: 删除所有话题及订阅\n     */\n    clearAll () {\n        this.observerListeners = {};\n        this.observerToken = 0;\n    }\n}\n\n\n//# sourceURL=webpack://markjs/./src/src/observer.js?"
        );

        /***/
      },

    /***/ "./src/src/plugins/edit.js":
      /*!*********************************!*\
  !*** ./src/src/plugins/edit.js ***!
  \*********************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          "__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EditPlugin)\n/* harmony export */ });\n/* harmony import */ var _markItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../markItem */ \"./src/src/markItem.js\");\n\n\n/*\n配置\n{\n    value: [\n        {\n            data: null,//附加数据\n            pointArr: [{// 点位数据\n                {\"x\":0,\"y\":0}\n            }],\n            strokeStyle: {},\n            fillColor: '',\n            pointStyle:{}\n        }\n    ],// 回显的标注区域数据\n    fillColor: String, // 标注区域填充颜色\n    strokeStyle: { // 标注轮廓样式\n        lineWidth: 3, // 线条宽度\n        strokeColor: 'rgba(0, 136, 255, 1)', // 线条颜色\n        lineJoin: 'round' // 线条末端样式\n    },\n    pointStyle: {// 端点的样式\n        lineWidth: 3,\n        strokeColor: 'rgba(0, 136, 255, 1)',\n        fillColor: 'rgba(0, 136, 255, 0.5)'\n    },\n    showPoint: true,// 是否绘制端点，默认true\n    pointType: '',// 端点类型，square（正方形）、circle（圆形），默认square\n    pointWidth: 4,// 端点的宽度，正方形的边长的一半、圆形的半径，默认3\n    customRenderPoint(ctx, x, y, onlyPath, pointStyle) {// 自定义绘制端点方法\n        // ctx（canvas绘图上下文）、x,y（中心点的位置）、onlyPath（为true代表用于检测点是否在该端点路径内时调用，此时不应该实际绘制出来，只要绘制路径即可）、pointStyle（端点样式）\n    },\n    max: 3,// 同时最多标注对象数量，默认-1，不限制\n    hoverActive: false,// 鼠标滑过对象时显示可激活状态，默认false\n    readonly: false,// 是否只读，默认false\n    single: false,// 是否编辑某个区域时隐藏其他所有区域，默认false\n    noCrossing: false,// 是否禁止某个标注对象自身线段交叉，和其他标注对象还是可以交叉的\n    dbClickRemovePoint: false,// 是否允许双击顶点删除该顶点\n    area: false,// 区域模式，从始至终都是一个闭合的图形\n    adsorbent: true,// 是否开启吸附效果\n    adsorbentNum: 5,// 吸附的距离，即距离小于等于该值时进行吸附\n    adsorbentLine: true,// 是否允许吸附到线段上\n    dbClickActive: false,// 是否双击激活标注对象，默认为单击激活\n    singleClickComplete: true,// 默认情况下，双击结束编辑，如果该值设为true，除了新增创建期间外的编辑下如果单击了其他区域也可以结束编辑，设为false，即只允许双击结束编辑\n    enableAddPoint: false,// 是否允许新增节点，仅在闭合情况下的编辑期间\n}\n\n属性\n\n事件\nCURRENT-MARK-ITEM-CHANGE（当前激活标注对象变化）\nHOVER-ITEM（鼠标移到某个标注对象区域内）\nCOMPLETE-EDIT-ITEM（双击完成绘制）\nIS-CREATE-MARKING-CHANGE（当前是否在创建中状态变化）\n\n方法\n\n插件开发\n插件需要返回一个promise，resolve之后才会加载下一个插件，所以插件的use顺序十分重要\n*/\n\n// 默认配置\nconst defaultOpt = {\n    value: [],\n    max: -1,\n    hoverActive: false,\n    readonly: false,\n    single: false,\n    noCrossing: false,\n    dbClickRemovePoint: false,\n    area: false,\n    adsorbent: true,\n    adsorbentNum: 5,\n    adsorbentLine: true,\n    dbClickActive: false,\n    singleClickComplete: true,\n    enableAddPoint: false\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2020-10-15 10:25:23 \n * @Desc: 编辑插件\n */\nfunction EditPlugin(instance, utils) {\n    let _resolve = null\n    let promise = new Promise((resolve) => {\n        _resolve = resolve\n    })\n    let opt = {\n        ...defaultOpt,\n        ...instance.opt\n    }\n    // 修改鼠标插件的默认配置\n    if (opt.dbClickActive) {\n        if (instance.opt.cursorTips) {\n            if (!instance.opt.cursorTips.HOVER) {\n                instance.opt.cursorTips.HOVER = '双击激活该区域并进入编辑状态'\n            }\n        } else {\n            instance.opt.cursorTips = {\n                HOVER: '双击激活该区域并进入编辑状态'\n            }\n        }\n    }\n    // 全部的标注对象列表\n    let markItemList = []\n    // 当前编辑中的标注对象\n    let curEditingMarkItem = null\n    // 拖动整体时的起始位置\n    let dragStartPos = {\n        x: 0,\n        y: 0\n    }\n    // 缓存一份拖动整体时的起始位置\n    let dragStartPosCache = {\n        x: 0,\n        y: 0\n    }\n    // 编辑中\n    let isReadonly = opt.readonly\n    // 是否新增标注中，不包括闭合后的编辑\n    let isCreateMarking = false\n    // 创建新标注时的配置项\n    let createMarkItemOpt = null\n    // 缓存点位数据\n    let cachePointArr = null\n    // 标注对象递增id\n    let mId = 0\n    // 当前的吸附值，用来在修正点击事件要新增的顶点的坐标值\n    let adsorbentedPos = null\n    // 吸附整体时的偏移量\n    let adsorbentedWholePos = [0, 0]\n    // 用来控制整体吸附后的脱离\n    let adsorbentedWholePosCacheMousePos = {x: 0, y: 0}\n    // 刚才是否处于拖动中，用来修复click事件比mouseup事件慢的问题\n    let lastIsDragging = false\n    // 创建一个只用于渲染吸附时的顶点的标注对象\n    let adsorbentMark = createNewMarkItem()\n\n    // 监听配置更新事件\n    instance.on('UPDATED_OPT', (o) => {\n        opt = {\n            ...defaultOpt,\n            ...instance.opt\n        }\n        instance.clearCanvas()\n        markItemList.forEach((item) => {\n            item.updateOpt(opt)\n            item.render()\n        })\n    })\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-21 15:54:21 \n     * @Desc: 回显数据 \n     */\n    function reShow() {\n        if (opt.value.length > 0) {\n            opt.value.forEach((item) => {\n                let _markItem = new _markItem__WEBPACK_IMPORTED_MODULE_0__[\"default\"](instance.ctx, {\n                    id: mId++,\n                    ...opt,\n                    ...item,\n                    pointArr: item.pointArr.map((point) => {\n                        return {\n                            x: point.x * instance.canvasEleRectInfo.width,\n                            y: point.y * instance.canvasEleRectInfo.height\n                        }\n                    }),\n                })\n                _markItem.closePath()\n                markItemList.push(_markItem)\n            })\n            render()\n        }\n    }\n    reShow()\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-16 15:34:49 \n     * @Desc: 获取所有变量的值 \n     */\n    function getState() {\n        return {\n            markItemList,\n            curEditingMarkItem,\n            isReadonly,\n            isCreateMarking\n        }\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 16:46:38 \n     * @Desc: 创建新标注对象实例 \n     */\n    function createNewMarkItem(plusOpt = {}) {\n        return new _markItem__WEBPACK_IMPORTED_MODULE_0__[\"default\"](instance.ctx, {\n            id: mId++,\n            ...opt,\n            ...createMarkItemOpt,\n            ...plusOpt,\n            area: opt.area\n        })\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-09-27 15:56:19 \n     * @Desc: 绘制 \n     */\n    function render() {\n        instance.clearCanvas()\n        if (opt.single && (curEditingMarkItem || isCreateMarking)) {\n            curEditingMarkItem && curEditingMarkItem.render()\n        } else {\n            markItemList.forEach((item) => {\n                item.render()\n            })\n        }\n        // 渲染吸附提示点\n        if (adsorbentedPos) {\n            adsorbentMark.drawPoint(adsorbentedPos[0], adsorbentedPos[1], false, true)\n        }\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 15:25:19 \n     * @Desc: 清除对象的编辑状态\n     */\n    function disableAllItemsEdit() {\n        markItemList.forEach((item) => {\n            item.disable()\n        })\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 19:14:36 \n     * @Desc: 清除对象鼠标滑过显示可选择状态 \n     */\n    function disableAllItemsHoverActive() {\n        markItemList.forEach((item) => {\n            item.disableHoverActive()\n        })\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 15:07:31 \n     * @Desc: 检查包含某个点的标注对象 \n     *  从后往前遍历是因为后面绘制的层级更高\n     */\n    function checkInPathItem(x, y) {\n        for (let i = markItemList.length - 1; i >= 0; i--) {\n            let item = markItemList[i]\n            if (item.checkInPath(x, y) || item.checkInPoints(x, y) !== -1) {\n                return item\n            }\n        }\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-11-02 17:48:18 \n     * @Desc: 找出所有包含该点的标注对象 \n     */\n    function checkInPathAllItems(x, y) {\n        let items = []\n        for (let i = markItemList.length - 1; i >= 0; i--) {\n            let item = markItemList[i]\n            if (item.checkInPath(x, y) || item.checkInPoints(x, y) !== -1) {\n                items.push(item) \n            }\n        }\n        return items\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 20:00:59 \n     * @Desc: 获取标注点位数据 \n     */\n    function getMarkData() {\n        return markItemList.map((item) => {\n            let pointArr = item.pointArr.map((point) => {\n                return {\n                    x: point.x / instance.canvasEleRectInfo.width,\n                    y: point.y / instance.canvasEleRectInfo.height\n                }\n            })\n            return {\n                data: item.data,\n                pointArr\n            }\n        })\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-21 11:29:16 \n     * @Desc: 当前是否正在创建新标注中，即当前标注还未闭合 \n     */\n    function getIsCreateIngMarkItem () {\n        return curEditingMarkItem && !curEditingMarkItem.isClosePath\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-16 09:41:24 \n     * @Desc: 开启编辑模式 \n     */\n    function enableEdit () {\n        isReadonly = false\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-21 14:58:24 \n     * @Desc: 清除所有状态 \n     */\n    function reset() {\n        disableAllItemsHoverActive()\n        disableAllItemsEdit()\n        setMarkEditItem(null)\n        render()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-16 09:41:40 \n     * @Desc: 开启只读模式，返回false代表当前有正在编辑中的对象，不能结束编辑\n     */\n    function disableEdit () {\n        if (getIsCreateIngMarkItem()) {\n            return false\n        }\n        reset()\n        isReadonly = true\n        return true\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-16 09:49:13 \n     * @Desc: 设置当前创建状态\n     */\n    function setIsCreateMarking (state) {\n        if (isReadonly) {\n            return false\n        }\n        isCreateMarking = state\n        instance.emit('IS-CREATE-MARKING-CHANGE', state)\n        return true\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-21 11:03:49 \n     * @Desc: 创建新标注，返回false代表不能创建新标注\n     * _opt：配置项，可添加MarkItem的所有配置项\n     */\n    function createMarkItem(_opt = null) {\n        if (getIsCreateIngMarkItem() || isReadonly) {\n            return false\n        }\n        reset()\n        createMarkItemOpt = _opt\n        setIsCreateMarking(true)\n        if (opt.single) {\n            instance.clearCanvas()\n        }\n        return true\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-21 18:58:23 \n     * @Desc: 取消/退出创建\n     * single为true的情况下编辑某个区域想要退出时可以调用reset方法\n     */\n    function exitCreate() {\n        if (!isCreateMarking) {\n            return false\n        } \n        setIsCreateMarking(false)\n        if (getIsCreateIngMarkItem()) {\n            let index = markItemList.findIndex((item) => {\n                return item === curEditingMarkItem\n            })\n            markItemList.splice(index, 1)\n        }\n        reset()\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-16 09:49:13 \n     * @Desc: 设置当前激活标注对象 \n     */\n    function setMarkEditItem (item) {\n        if (isReadonly) {\n            return false\n        }\n        curEditingMarkItem = item\n        instance.emit('CURRENT-MARK-ITEM-CHANGE', item)\n        return true\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-16 10:31:25 \n     * @Desc: 删除指定标注对象 \n     */\n    function deleteMarkItem (item) {\n        if (!item) {\n            return false\n        }\n        let index = markItemList.findIndex((i) => {\n            return i === item\n        })\n        if (index !== -1) {\n            if (curEditingMarkItem === item) {\n                setMarkEditItem(null)\n            }\n            let deleteItem = markItemList.splice(index, 1)\n            render()\n            instance.emit('DELETE-MARKING-ITEM', deleteItem[0], index)\n            return true\n        }\n        return false\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-16 10:31:33 \n     * @Desc: 删除所有标注对象 \n     */\n    function deleteAllMarkItem () {\n        markItemList = []\n        setMarkEditItem(null)\n        render()\n        instance.emit('DELETE-ALL-MARKING-ITEM')\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-01-22 09:50:40 \n     * @Desc: 吸附效果 \n     */\n    function checkAdsorbent(x, y) {\n        if (!opt.adsorbent) {\n            return [x, y]\n        }\n        let min = Infinity\n        let _x = x, _y = y\n        let _adsorbentedPos = null\n        markItemList.forEach((item) => {\n            // 端点\n            item.pointArr.forEach((point, index) => {\n                // 跳过自己和自己的比较\n                if (curEditingMarkItem && item === curEditingMarkItem && item.dragPointIndex === index) {\n                    return\n                }\n                let d = utils.getTwoPointDistance(point.x, point.y, x, y)\n                if (d <= opt.adsorbentNum && d < min) {\n                    min = d\n                    _x = point.x\n                    _y = point.y\n                    _adsorbentedPos = [_x, _y]\n                }\n            })\n            // 线段\n            if (opt.adsorbentLine) {\n                let nearestLine = item.getPintNearestLine(x, y)\n                if (nearestLine && nearestLine[0] <= opt.adsorbentNum) {\n                    let points = nearestLine[1]\n                    let pointA = points[0]\n                    let pointB = points[1]\n                    let minx = Math.min(pointA.x, pointB.x)\n                    let maxx = Math.max(pointA.x, pointB.x)\n                    if (x >= minx && x <= maxx) {\n                        let nearestPoint = utils.getNearestPointFromLine(pointA.x, pointA.y, pointB.x, pointB.y, x, y)\n                        _x = nearestPoint[0]\n                        _y = nearestPoint[1]\n                        _adsorbentedPos = [_x, _y]\n                    }\n                }\n            }\n        })\n        adsorbentedPos = _adsorbentedPos\n        return [_x, _y]\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-01-23 11:11:01 \n     * @Desc: 吸附整体 \n     */\n    function checkAdsorbentWhole(x, y) {\n        if (!opt.adsorbent) {\n            return [x, y]\n        }\n        let min = Infinity\n        let minPoint = null\n        let minPoint2 = null\n        // 遍历当前图形和其他图形最近的两个顶点\n        curEditingMarkItem.pointArr.forEach((pointItem) => {\n            markItemList.forEach((markItem) => {\n                if (markItem !== curEditingMarkItem) {\n                    markItem.pointArr.forEach((markItemPointItem) =>{\n                        let d = utils.getTwoPointDistance(pointItem.x, pointItem.y, markItemPointItem.x, markItemPointItem.y)\n                        if (d < min) {\n                            min = d\n                            minPoint = pointItem\n                            minPoint2 = markItemPointItem\n                        }\n                    })\n                }\n            })\n        })\n        if (min <= opt.adsorbentNum) {\n            adsorbentedWholePos = [minPoint2.x - minPoint.x, minPoint2.y - minPoint.y]\n            dragStartPos.x -= adsorbentedWholePos[0]\n            dragStartPos.y -= adsorbentedWholePos[1]\n        }\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:12:55 \n     * @Desc: 监听单击事件 \n     */\n    instance.on('CLICK', (e) => {\n        if (isReadonly) {\n            return\n        }\n        if (!opt.mobile && lastIsDragging) {\n            lastIsDragging = false\n            return\n        }\n        let {\n            x,\n            y\n        } = instance.toCanvasPos(e)\n        // 检查点击的位置是否存在标注对象\n        let inPathItem = null\n         // 创建新对象\n        if (isCreateMarking) {\n            let _x = x\n            let _y = y\n            // 如果存在吸附数据则使用吸附数据\n            if (adsorbentedPos) {\n                _x = adsorbentedPos[0]\n                _y = adsorbentedPos[1]\n                adsorbentedPos = null\n            }\n            // 当前存在尚未闭合的激活对象\n            if (curEditingMarkItem) {\n                // 检查线段是否交叉\n                if (opt.noCrossing) {\n                    let cross = curEditingMarkItem.checkNextLineSegmentCross(_x, _y)\n                    if (cross) {\n                        instance.emit('LINE-CROSS', curEditingMarkItem)\n                    } else {\n                        curEditingMarkItem.pushPoint(_x, _y)\n                    }\n                } else {\n                    curEditingMarkItem.pushPoint(_x, _y)\n                }\n            } else {// 当前没有这种标注中的对象\n                // 数量判断\n                if (opt.max === -1 || markItemList.length < opt.max) {\n                    disableAllItemsEdit()\n                    setMarkEditItem(createNewMarkItem())\n                    curEditingMarkItem.enable()\n                    curEditingMarkItem.pushPoint(_x, _y)\n                    markItemList.push(curEditingMarkItem)\n                } else { // 超出数量限制\n                    instance.emit('COUNT-LIMIT', curEditingMarkItem)\n                    setIsCreateMarking(false)\n                }\n            }\n        } else if (inPathItem = checkInPathItem(x, y)) { // 当前点击的位置存在标注对象\n            // !(opt.single && curEditingMarkItem) && \n            if (!opt.dbClickActive && !checkInPathAllItems(x, y).includes(curEditingMarkItem)) {\n                if (!opt.single || (opt.single && !curEditingMarkItem)) {\n                    disableAllItemsEdit()\n                    inPathItem.enable()\n                    setMarkEditItem(inPathItem)\n                }\n            }\n        } else {// 点击空白处清除当前所有状态\n            if (!opt.single && opt.singleClickComplete) {\n                reset()\n            }\n        }\n        render()\n    })\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 14:14:57 \n     * @Desc: 监听双击事件 \n     */\n    instance.on('DOUBLE-CLICK', (e) => {\n        if (isReadonly) {\n            return\n        }\n        let {\n            x,\n            y\n        } = instance.toCanvasPos(e)\n        // 能否激活其他对象\n        let canActive = true\n        // 检查当前双击的位置最上层的编辑对象\n        let inPathItem = checkInPathItem(x, y)\n        // 检查当前双击的对象是否和当前编辑中的对象是同一个\n        let isSame = inPathItem && curEditingMarkItem ? inPathItem === curEditingMarkItem : false\n        // 当前存在编辑中的对象\n        if (curEditingMarkItem) {\n            // 点击的是顶点\n            let inPointIndex = curEditingMarkItem.checkInPoints(x, y)\n            if (opt.dbClickRemovePoint && inPointIndex !== -1) {\n                canActive = false\n                if (curEditingMarkItem.getPointLength() > 3) {\n                    curEditingMarkItem.removePoint(inPointIndex)\n                    render()\n                } else {\n                    instance.emit('NOT-ENOUGH-POINTS-REMOVE', curEditingMarkItem)\n                }\n            } else {\n                // 端点数量不足三个\n                if (curEditingMarkItem.getPointLength() < 3) {\n                    canActive = false\n                    instance.emit('NOT-ENOUGH-END-POINTS', curEditingMarkItem)\n                } else if (opt.noCrossing && curEditingMarkItem.checkEndLineSegmentCross()) {// 线段存在交叉\n                    canActive = false\n                    instance.emit('LINE-CROSS', curEditingMarkItem)\n                } else {\n                    if (isCreateMarking) {\n                        instance.emit('COMPLETE-CREATE-ITEM', curEditingMarkItem, e)\n                    }\n                    setIsCreateMarking(false)\n                    curEditingMarkItem.closePath()\n                    curEditingMarkItem.disable()\n                    adsorbentedPos = null\n                    setMarkEditItem(null)\n                    render()\n                    instance.emit('COMPLETE-EDIT-ITEM', curEditingMarkItem, e)\n                }\n            }\n        }\n        // 双击激活标注对象\n        if (opt.dbClickActive && !isCreateMarking && canActive && inPathItem && !isSame) {\n            disableAllItemsEdit()\n            inPathItem.enable()\n            setMarkEditItem(inPathItem)\n            render()\n        }\n    })\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 15:43:14 \n     * @Desc: 监听鼠标按下事件 \n     */\n    instance.on('MOUSEDOWN', (e) => {\n        if (isReadonly) {\n            return\n        }\n        let {\n            x,\n            y\n        } = instance.toCanvasPos(e)\n        if (!curEditingMarkItem || !curEditingMarkItem.isEditing || !curEditingMarkItem.isClosePath) {\n            return\n        }\n        // 判断是否在端点内\n        let inPointIndex = curEditingMarkItem.checkInPoints(x, y)\n        // 是否在路径内\n        let isInPath = curEditingMarkItem.checkInPath(x, y)\n        if (isInPath || inPointIndex !== -1) {\n            if (opt.noCrossing) {\n                cachePointArr = JSON.parse(JSON.stringify(curEditingMarkItem.pointArr))\n            }\n            dragStartPos.x = x\n            dragStartPos.y = y\n            dragStartPosCache.x = x\n            dragStartPosCache.y = y\n            curEditingMarkItem.enableDrag(inPointIndex)\n        }\n    })\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 16:57:32 \n     * @Desc: 监听鼠标移动事件 \n     */\n    instance.on('MOUSEMOVE', (e) => {\n        if (isReadonly) {\n            return\n        }\n        let {\n            x,\n            y\n        } = instance.toCanvasPos(e)\n        // 拖动编辑\n        if (curEditingMarkItem && curEditingMarkItem.isDragging) {\n            if (curEditingMarkItem.dragPointIndex !== -1) {// 拖动单个顶点\n                curEditingMarkItem.dragPoint(...checkAdsorbent(x, y), instance)\n            } else {// 拖动整体图形\n                checkAdsorbentWhole()\n                // 控制吸附后的脱离\n                if (adsorbentedWholePos[0] !== 0 && adsorbentedWholePos[1] !== 0 && adsorbentedWholePosCacheMousePos.x === 0 && adsorbentedWholePosCacheMousePos.y === 0) {\n                    adsorbentedWholePosCacheMousePos.x = x\n                    adsorbentedWholePosCacheMousePos.y = y\n                }\n                if (adsorbentedWholePosCacheMousePos.x !== 0 && adsorbentedWholePosCacheMousePos.y !== 0) {\n                    if (utils.getTwoPointDistance(adsorbentedWholePosCacheMousePos.x, adsorbentedWholePosCacheMousePos.y, x, y) > opt.adsorbentNum) {\n                        adsorbentedWholePos = [0, 0]\n                        dragStartPos.x = dragStartPosCache.x\n                        dragStartPos.y = dragStartPosCache.y\n                        adsorbentedWholePosCacheMousePos.x = 0\n                        adsorbentedWholePosCacheMousePos.y = 0\n                    }\n                }\n                let ox = x - dragStartPos.x\n                let oy = y - dragStartPos.y\n                curEditingMarkItem.dragAll(ox, oy)\n            }\n            render()\n            let inPointIndex = curEditingMarkItem.checkInPoints(x, y)\n            instance.emit('HOVER-ITEM', curEditingMarkItem, curEditingMarkItem, checkInPathAllItems(x, y), e, inPointIndex)\n        } else if(isCreateMarking) {// 创建新标注中\n            let ox = x - dragStartPos.x\n            let oy = y - dragStartPos.y\n            let apos = checkAdsorbent(ox, oy)\n            // 始终闭合模式\n            if (opt.area && curEditingMarkItem) {\n                curEditingMarkItem.areaToPoint(...apos)\n            }\n            render()\n        } else if(!isCreateMarking){// 显示可选择状态\n            let inPathItem = checkInPathItem(x, y)\n            // 鼠标滑过显示可选择状态\n            if (opt.hoverActive && (!curEditingMarkItem || curEditingMarkItem.isClosePath)) {\n                disableAllItemsHoverActive()\n                inPathItem && inPathItem.enableHoverActive()\n                render()\n            }\n            if (inPathItem && inPathItem.isClosePath) {\n                let inPointIndex = inPathItem.checkInPoints(x, y)\n                instance.emit('HOVER-ITEM', inPathItem, curEditingMarkItem, checkInPathAllItems(x, y), e, inPointIndex)\n            }\n        }\n    })\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-15 18:31:56 \n     * @Desc: 监听鼠标松开事件 \n     */\n    instance.on('MOUSEUP', (e) => {\n        if (isReadonly) {\n            return\n        }\n        if (curEditingMarkItem && curEditingMarkItem.isDragging) {\n            lastIsDragging = true\n            curEditingMarkItem.disableDrag()\n            dragStartPos.x = 0\n            dragStartPos.y = 0\n            dragStartPosCache.x = 0\n            dragStartPosCache.y = 0\n            if (opt.noCrossing && curEditingMarkItem.checkLineSegmentCross()) {\n                instance.emit('LINE-CROSS', curEditingMarkItem)\n                curEditingMarkItem.pointArr = cachePointArr\n                cachePointArr = null\n            }\n            render()\n        }\n    })\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2020-10-16 09:42:10 \n     * @Desc: 暴露方法给实例引用 \n     */\n    instance._disableAllItemsEdit = disableAllItemsEdit\n    instance._setMarkEditItem = setMarkEditItem\n    instance._createNewMarkItem = createNewMarkItem\n    instance._setIsCreateMarking = setIsCreateMarking\n    instance._render = render\n    instance._disableAllItemsHoverActive = disableAllItemsHoverActive\n    instance._checkInPathItem = checkInPathItem\n    instance._checkInPathAllItems = checkInPathAllItems\n    instance._getIsCreateIngMarkItem = getIsCreateIngMarkItem\n\n    instance.getState = getState\n    instance.getMarkData = getMarkData\n    instance.enableEdit = enableEdit\n    instance.disableEdit = disableEdit\n    instance.deleteMarkItem = deleteMarkItem\n    instance.deleteAllMarkItem = deleteAllMarkItem\n    instance.createMarkItem = createMarkItem\n    instance.exitCreate = exitCreate\n    instance.reset = reset\n\n    _resolve()\n    return promise\n}\n\n//# sourceURL=webpack://markjs/./src/src/plugins/edit.js?"
        );

        /***/
      },

    /***/ "./src/src/utils.js":
      /*!**************************!*\
  !*** ./src/src/utils.js ***!
  \**************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2020-10-21 20:27:55 \n * @Desc: 判断两条线段是否交叉 \n */\nfunction checkLineSegmentCross(a, b, c, d) {\n  let cross = false\n  // 向量\n  let ab = [b.x - a.x, b.y - a.y]\n  let ac = [c.x - a.x, c.y - a.y]\n  let ad = [d.x - a.x, d.y - a.y]\n  // 向量叉乘，判断点c,d分别在线段ab两侧，条件1\n  let abac = ab[0] * ac[1] - ab[1] * ac[0]\n  let abad = ab[0] * ad[1] - ab[1] * ad[0]\n\n  // 向量\n  let dc = [c.x - d.x, c.y - d.y]\n  let da = [a.x - d.x, a.y - d.y]\n  let db = [b.x - d.x, b.y - d.y]\n  // 向量叉乘，判断点a,b分别在线段dc两侧，条件2\n  let dcda = dc[0] * da[1] - dc[1] * da[0]\n  let dcdb = dc[0] * db[1] - dc[1] * db[0]\n\n  // 同时满足条件1，条件2则线段交叉\n  if (abac * abad < 0 && dcda * dcdb < 0) {\n    cross = true\n  }\n  return cross\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2021-01-22 10:27:00 \n * @Desc: 求点到直线的距离 \n */\nfunction getLinePointDistance(x1, y1, x2, y2, x, y) {\n  // 直线垂直于x轴\n  if (x1 === x2) {\n    return Math.abs(x - x1)\n  } else {\n    let B = 1\n    let A, C\n    A = (y1 - y2) / (x2 - x1)\n    C = 0 - B * y1 - A * x1\n    return Math.abs((A * x + B * y + C) / Math.sqrt(A * A + B * B))\n  }\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2021-01-22 17:28:15 \n * @Desc:  计算两点间连线的倾斜角\n */\nfunction getAngle(x1, y1, x2, y2) {\n  let a = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI\n  return a > 0 ? a - 360 : a\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2021-01-22 14:25:25 \n * @Desc: 根据某条直线上的点x坐标获取y坐标 \n */\nfunction getLinePointYByX(x1, y1, x2, y2, x) {\n  // 直线垂直于x轴\n  if (x1 === x2) {\n    return Math.min(y1, y2)\n  } else {\n    let B = 1\n    let A, C\n    A = (y1 - y2) / (x2 - x1)\n    C = 0 - B * y1 - A * x1\n\n    const getY = (x) => {\n      return (0 - C - A * x) / B\n    }\n\n    return getY(x)\n  }\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2021-01-22 14:11:43 \n * @Desc: 获取某条直线上的所有点 \n */\nfunction getLineAllPoint(x1, y1, x2, y2) {\n  let arr = []\n  // 直线垂直于x轴\n  if (x1 === x2) {\n    let dy = Math.abs(y2 - y1)\n    let min = Math.min(y1, y2)\n    for (let i = 0; i <= dy; i++) {\n      arr.push([x1, min + i])\n    }\n  } else {\n    let B = 1\n    let A, C\n    A = (y1 - y2) / (x2 - x1)\n    C = 0 - B * y1 - A * x1\n\n    const getY = (x) => {\n      return (0 - C - A * x) / B\n    }\n\n    let dx = Math.abs(x2 - x1)\n    let min = Math.min(x1, x2)\n    for (let i = 0; i <= dx; i++) {\n      arr.push([min + i, getY(min + i)])\n    }\n  }\n  return arr\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2021-01-22 09:53:54 \n * @Desc: 两点距离公式 \n */\nfunction getTwoPointDistance(x1, y1, x2, y2) {\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2))\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2021-01-22 17:25:43 \n * @Desc: 获取一条线段上距离某个点最近的点 \n */\nfunction getNearestPointFromLine(x1, y1, x2, y2, x, y) {\n  let arr = getLineAllPoint(x1, y1, x2, y2)\n  let min = Infinity\n  let minPoint = null\n  arr.forEach((item) => {\n    let d = getTwoPointDistance(item[0], item[1], x, y)\n    if (d < min) {\n      min = d\n      minPoint = item\n    }\n  })\n  return minPoint\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2020-10-22 10:34:19 \n * @Desc: 加载图片 \n */\nfunction loadImage(src) {\n  return new Promise((resolve, reject) => {\n    let img = new Image()\n    img.onload = () => {\n      resolve(img)\n    }\n    img.onerror = e => {\n      reject(e)\n    }\n    img.src = src\n  })\n}\n\n/** \n * javascript comment \n * @Author: 王林25 \n * @Date: 2020-10-15 13:42:44 \n * @Desc: 工具方法 \n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  checkLineSegmentCross,\n  loadImage,\n  getTwoPointDistance,\n  getLinePointYByX,\n  getLineAllPoint,\n  getLinePointDistance,\n  getAngle,\n  getNearestPointFromLine\n});\n\n//# sourceURL=webpack://markjs/./src/src/utils.js?'
        );

        /***/
      },

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ // no module.id needed
      /******/ // no module.loaded needed
      /******/ exports: {},
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId](
      module,
      module.exports,
      __webpack_require__
    );
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/compat get default export */
  /******/ (() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = (module) => {
      /******/ var getter =
        module && module.__esModule
          ? /******/ () => module["default"]
          : /******/ () => module;
      /******/ __webpack_require__.d(getter, { a: getter });
      /******/ return getter;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key],
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __webpack_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (exports) => {
      /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: "Module",
        });
        /******/
      }
      /******/ Object.defineProperty(exports, "__esModule", { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /************************************************************************/
  /******/
  /******/ // startup
  /******/ // Load entry module and return exports
  /******/ // This entry module can't be inlined because the eval devtool is used.
  /******/ var __webpack_exports__ = __webpack_require__("./src/index.js");
  /******/
  /******/
})();
